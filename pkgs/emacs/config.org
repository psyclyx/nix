#+TITLE: Emacs configuration
#+AUTHOR: psyclyx
#+PROPERTY: header-args :tangle yes

Draws *heavily* from doomemacs.

* Startup
** Lexical binding
#+begin_src emacs-lisp :comments no
  ;;; -*- lexical-binding: t -*-
#+end_src

** Configure GC
#+begin_src emacs-lisp
  ;; startup
  (defvar my/gc-cons-threshold-high most-positive-fixnum)
  (defvar my/gc-cons-threshold (* 96 1024 1024))

  (defun my/disable-gc ()
    (setq gc-cons-threshold my/gc-cons-threshold-high))


  (defun my/enable-gc ()
    (setq gc-cons-threshold my/gc-cons-threshold))

  (my/disable-gc)

  (let ((file-name-handler-alist-cache file-name-handler-alist))
    (setq file-name-handler-alist nil)
    (add-hook 'emacs-startup-hook
              #'(lambda ()
                  (my/enable-gc)
                  (setq file-name-handler-alist file-name-handler-alist-cache))))

  (add-hook 'minibuffer-setup-hook #'my/disable-gc)
  (add-hook 'minibuffer-exit-hook #'my/enable-gc)

  (defun my/completion-in-region-disable-gc ()
    (if completion-in-region-mode
        (progn
          (my/disable-gc))
      (my/enable-gc)))

  (add-hook 'focus-out-hook #'garbage-collect)
#+end_src


* Editor
** File handling
*** Symlinks
#+begin_src emacs-lisp
  (setq find-file-visit-truename t
        vc-follow-symlinks t)
#+end_src
*** Suppress same file warnings
#+begin_src emacs-lisp
  (setq find-file-suppress-same-file-warnings t)
#+end_src
*** Disable lockfiles/backups
#+begin_src emacs-lisp
  (setq create-lockfiles nil
        make-backup-files nil)
#+end_src
*** Create missing directories
#+begin_src emacs-lisp
  (defun my/create-missing-directories-h ()
    "Automatically create missing directories when creating new files."
    (unless (file-remote-p buffer-file-name)
      (let ((parent-directory (file-name-directory buffer-file-name)))
        (and (not (file-directory-p parent-directory))
             (y-or-n-p (format "Directory `%s' does not exist! Create it?"
                               parent-directory))
             (progn (make-directory parent-directory 'parents)
                    t)))))

  (add-hook 'find-file-not-found-functions #'my/create-missing-directories-h)
#+end_src
*** Guess mode on save
#+begin_src emacs-lisp
  (defun my/guess-mode-h ()
    "Guess major mode when saving a file in `fundamental-mode'.

  Likely, something has changed since the buffer was opened. e.g. A shebang line
  or file path may exist now."
    (when (eq major-mode 'fundamental-mode)
      (let ((buffer (or (buffer-base-buffer) (current-buffer))))
        (and (buffer-file-name buffer)
             (eq buffer (window-buffer (selected-window)))
             (set-auto-mode)
             (not (eq major-mode 'fundamental-mode))))))

  (add-hook 'after-save-hook #'my/guess-mode-h)
#+end_src
** Formatting
*** Indentation
#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil
                tab-width 4)
#+end_src

#+begin_src emacs-lisp
  (setq-default tab-always-indent nil)
#+end_src

#+begin_src emacs-lisp
  (setq tabify-regexp "^\t* [ \t]+")
#+end_src
*** Wrapping
#+begin_src emacs-lisp
  (setq-default truncate-lines t
                truncate-partial-width-windows nil)
#+end_src

#+begin_src emacs-lisp
  (setq-default word-wrap t)
#+end_src

#+begin_src emacs-lisp
  (add-hook 'text-mode-hook #'visual-line-mode)
#+end_src
*** Sentences
#+begin_src emacs-lisp
  (setq sentence-end-double-space nil)
#+end_src
*** Fill column
#+begin_src emacs-lisp
  (setq-default fill-column 80)
#+end_src
*** EOF newlines
#+begin_src emacs-lisp
  (setq require-final-newline t)
#+end_src
** Behavior
*** kill-ring
#+begin_src emacs-lisp
  (setq kill-do-not-save-duplicates t)
#+end_src
* Built-in packages
** recentf
#+begin_src emacs-lisp
  (use-package recentf
    :custom
    (recentf-max-saved-items 512)
    :init
    (recentf-mode 1))
#+end_src

** Savehist
#+begin_src emacs-lisp
  (use-package savehist
    :init
    (savehist-mode))
#+end_src

* Server
#+begin_src emacs-lisp
  (defun my/maybe-start-server ()
    (unless (server-running-p)
      (message "Starting server")
      (server-start)))

  (use-package server
    :demand t
    :hook (after-init . my/maybe-start-server)
    :if (display-graphic-p))
#+end_src

* Tramp
#+begin_src emacs-lisp
  (use-package tramp
    :custom
    (remote-file-name-inhibit-cache 60))
#+end_src

* Better jumper
#+begin_src emacs-lisp
  (use-package better-jumper
    :ensure t
    :hook (after-init . better-jumper-mode)
    :commands my/set-jump-a my/set-jump-maybe-a my/set-jump-h
    :preface
    ;; REVIEW Suppress byte-compiler warning spawning a *Compile-Log* buffer at
    ;; startup. This can be removed once gilbertw1/better-jumper#2 is merged.
    (defvar better-jumper-local-mode nil)
    ;; REVIEW: Remove if/when gilbertw1/better-jumper#26 is addressed.
    (defvaralias 'evil--jumps-jump-command 'evil--jumps-jumping-backward)
    :init
    (global-set-key [remap evil-jump-forward]  #'better-jumper-jump-forward)
    (global-set-key [remap evil-jump-backward] #'better-jumper-jump-backward)
    (global-set-key [remap xref-pop-marker-stack] #'better-jumper-jump-backward)
    (global-set-key [remap xref-go-back] #'better-jumper-jump-backward)
    (global-set-key [remap xref-go-forward] #'better-jumper-jump-forward)
    :config
    (defun my/set-jump-a (fn &rest args)
      "Set a jump point and ensure fn doesn't set any new jump points."
      (better-jumper-set-jump (if (markerp (car args)) (car args)))
      (let ((evil--jumps-jumping t)
            (better-jumper--jumping t))
        (apply fn args)))

    (defun my/set-jump-maybe-a (fn &rest args)
      "Set a jump point if fn actually moves the point."
      (let ((origin (point-marker))
            (result
             (let* ((evil--jumps-jumping t)
                    (better-jumper--jumping t))
               (apply fn args)))
            (dest (point-marker)))
        (unless (equal origin dest)
          (with-current-buffer (marker-buffer origin)
            (better-jumper-set-jump
             (if (markerp (car args))
                 (car args)
               origin))))
        (set-marker origin nil)
        (set-marker dest nil)
        result))

    (defun my/set-jump-h ()
      "Run `better-jumper-set-jump' but return nil, for short-circuiting hooks."
      (when (get-buffer-window)
        (better-jumper-set-jump))
      nil)

    ;; Creates a jump point before killing a buffer. This allows you to undo
    ;; killing a buffer easily (only works with file buffers though; it's not
    ;; possible to resurrect special buffers).
    ;;
    ;; I'm not advising `kill-buffer' because I only want this to affect
    ;; interactively killed buffers.
    (add-hook 'kill-buffer-hook #'my/set-jump-h)

    ;; Create a jump point before jumping with imenu.
    (advice-add #'imenu :around #'my/set-jump-a))
#+end_src

* Smartparens
#+begin_src emacs-lisp
  (use-package smartparens
    :ensure t
    :hook (after-init . smartparens-global-mode)
    :commands sp-pair sp-local-pair sp-with-modes sp-point-in-comment sp-point-in-string
    :config
    (add-to-list 'sp-lisp-modes 'sly-mrepl-mode)
    (require 'smartparens-config)
    (setq sp-highlight-pair-overlay nil
          sp-highlight-wrap-overlay nil
          sp-highlight-wrap-tag-overlay nil)
    (with-eval-after-load 'evil
      (setq sp-show-pair-from-inside t
            sp-cancel-autoskip-on-backward-movement nil
            sp-pair-overlay-keymap (make-sparse-keymap)))

    (setq sp-max-prefix-length 25
          sp-max-pair-length 4)

    ;; Silence some harmless but annoying echo-area spam
    (dolist (key '(:unmatched-expression :no-matching-tag))
      (setf (alist-get key sp-message-alist) nil))

    (defun my/init-smartparens-in-eval-expression-h ()
      "Enable `smartparens-mode' in the minibuffer for `eval-expression'.
  This includes everything that calls `read--expression', e.g.
  `edebug-eval-expression' Only enable it if
  `smartparens-global-mode' is on."
      (when smartparens-global-mode (smartparens-mode +1)))

    (add-hook 'eval-expression-minibuffer-setup-hook
              #'my/init-smartparens-in-eval-expression-h)

    (defun my/init-smartparens-in-minibuffer-maybe-h ()
      "Enable `smartparens' for non-`eval-expression' commands.
  Only enable `smartparens-mode' if `smartparens-global-mode' is
  on."
      (when (and smartparens-global-mode (memq this-command '(evil-ex)))
        (smartparens-mode +1)))
    (add-hook 'minibuffer-setup-hook
              #'my/init-smartparens-in-minibuffer-maybe-h)

    (sp-local-pair '(minibuffer-mode minibuffer-inactive-mode) "'" nil :actions nil)
    (sp-local-pair '(minibuffer-mode minibuffer-inactive-mode) "`" nil :actions nil)

    (defvar my/buffer-smartparens-mode nil)

    (defun my/enable-smartparens-mode-maybe-h ()
      (when my/buffer-smartparens-mode
        (turn-on-smartparens-mode)
        (kill-local-variable 'doom-buffer-smartparens-mode)))
    (add-hook 'evil-replace-state-exit-hook
              #'my/enable-smartparens-mode-maybe-h)

    (defun my/disable-smartparens-mode-maybe-h ()
      (when smartparens-mode
        (setq-local my/buffer-smartparens-mode t)
        (turn-off-smartparens-mode)))
    (add-hook 'evil-replace-state-entry-hook
              #'my/disable-smartparens-mode-maybe-h))
#+end_src
