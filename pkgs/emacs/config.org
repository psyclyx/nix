#+TITLE: Emacs configuration
#+AUTHOR: psyclyx
#+PROPERTY: header-args :tangle yes

Draws *heavily* from doomemacs.

* Startup
** Lexical binding
#+begin_src emacs-lisp :comments no
  ;;; -*- lexical-binding: t -*-
#+end_src
** Configure GC
#+begin_src emacs-lisp
  ;; startup
  (defvar my/gc-cons-threshold-high most-positive-fixnum)
  (defvar my/gc-cons-threshold (* 96 1024 1024))

  (defun my/disable-gc ()
    (setq gc-cons-threshold my/gc-cons-threshold-high))

  (defun my/enable-gc ()
    (setq gc-cons-threshold my/gc-cons-threshold))

  (my/disable-gc)

  (let ((file-name-handler-alist-cache file-name-handler-alist))
    (setq file-name-handler-alist nil)
    (add-hook 'emacs-startup-hook
              #'(lambda ()
                  (my/enable-gc)
                  (setq file-name-handler-alist file-name-handler-alist-cache))))

  (add-hook 'minibuffer-setup-hook #'my/disable-gc)
  (add-hook 'minibuffer-exit-hook #'my/enable-gc)

  (defun my/completion-in-region-disable-gc ()
    (if completion-in-region-mode
        (progn
          (my/disable-gc))
      (my/enable-gc)))

  (add-hook 'focus-out-hook #'garbage-collect)
#+end_src

* UI
** Simplify
#+begin_src emacs-lisp
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (tooltip-mode -1)
  (setq initial-buffer-choice t)
#+end_src
** Visual bell
#+begin_src emacs-lisp
  (defun my/flash-modeline ()
    (invert-face 'mode-line)
    (run-with-timer 0.1 nil 'invert-face 'mode-line))

  (setq visible-bell nil
        ring-bell-function 'my/flash-modeline)
#+end_src
** Scroll
#+begin_src emacs-lisp
  (setq hscroll-margin 2
        hscroll-step 1
        scroll-conservatively 10
        scroll-margin 0
        scroll-preserve-screen-position t
        auto-window-vscroll nil
        mouse-wheel-scroll-amount '(2 ((shift) . hscroll))
        mouse-wheel-scroll-amount-horizontal 2)
#+end_src
** Cursor
#+begin_src emacs-lisp
  (blink-cursor-mode -1)
  (setq blink-matching-paren nil)
#+end_src

#+begin_src emacs-lisp
  (setq x-stretch-cursor nil)
#+end_src
** Fringes
#+begin_src emacs-lisp
  (setq indicate-buffer-boundaries nil
        indicate-empty-lines nil)
#+end_src
** Windows/Frames
#+begin_src emacs-lisp
  (setq frame-title-format '("%b â€“ Emacs")
        icon-title-format frame-title-format)
#+end_src

#+begin_src emacs-lisp
  (setq frame-resize-pixelwise t
        window-resize-pixelwise t)
#+end_src

#+begin_src emacs-lisp
  (setq window-divider-default-places t
        window-divider-default-bottom-width 1
        window-divider-default-right-width 1)

  (when (display-graphic-p)
    (add-hook 'after-init #'window-divider-mode))
#+end_src
** Splits
#+begin_src emacs-lisp
(setq split-width-threshold 160
      split-height-threshold nil)
#+end_src
** Tooltips
#+begin_src emacs-lisp
(when (bound-and-true-p tooltip-mode)
  (tooltip-mode -1))
#+end_src
** Theme
#+begin_src emacs-lisp
  (use-package zenburn-theme
    :ensure t
    :custom
    (zenburn-use-variable-pitch t)
    (zenburn-scale-org-headlines t)
    (zenburn-scale-outline-headings t)
    :init
    (load-theme 'zenburn t))
#+end_src
** Fonts
#+begin_src emacs-lisp
  (use-package faces
    :demand t
    :custom
    (face-font-family-alternatives
     '(("Berkeley Mono" "Aporetic Sans Mono" "Noto Sans Mono" "SF Mono" "Menlo" "Monospace")
       ("Aporetic Sans" "Noto Sans" "Noto Sans" "SF Pro" "Helvetica" "Arial")))
    :config
    (set-face-attribute 'default nil
                        :family "Berkeley Mono"
                        :height 180
                        :weight 'extra-light
                        :width 'condensed)

    (set-face-attribute 'fixed-pitch nil
                        :family "Berkeley Mono")

    (set-face-attribute 'variable-pitch nil
                        :family "Aporetic Sans"))
#+end_src
** Icons
#+begin_src emacs-lisp
    (use-package nerd-icons
      :ensure t)

    (use-package nerd-icons-corfu
      :ensure t
      :after (corfu nerd-icons)
      :config
      (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))

    (use-package nerd-icons-completion
      :ensure t
      :config
      (nerd-icons-completion-mode)
      (add-hook 'marginalia-mode-hook #'nerd-icons-completion-marginalia-setup))
#+end_src
** Modeline
#+begin_src emacs-lisp
  (use-package mood-line
    :ensure t
    :custom
    (mood-line-glyph-alist mood-line-glyphs-unicode)
    (mood-line-format mood-line-format-default-extended)
    :config
    (mood-line-mode))
#+end_src
#+begin_src emacs-lisp
  (set-face-attribute 'mode-line nil :box
                      '(:line-width (8 . 8) :style flat-button))
#+end_src
* Editor
** File handling
*** Symlinks
#+begin_src emacs-lisp
  (setq find-file-visit-truename t
        vc-follow-symlinks t)
#+end_src
*** Suppress same file warnings
#+begin_src emacs-lisp
  (setq find-file-suppress-same-file-warnings t)
#+end_src
*** Disable lockfiles/backups
#+begin_src emacs-lisp
  (setq create-lockfiles nil
        make-backup-files nil)
#+end_src
*** Create missing directories
#+begin_src emacs-lisp
  (defun my/create-missing-directories-h ()
    "Automatically create missing directories when creating new files."
    (unless (file-remote-p buffer-file-name)
      (let ((parent-directory (file-name-directory buffer-file-name)))
        (and (not (file-directory-p parent-directory))
             (y-or-n-p (format "Directory `%s' does not exist! Create it?"
                               parent-directory))
             (progn (make-directory parent-directory 'parents)
                    t)))))

  (add-hook 'find-file-not-found-functions #'my/create-missing-directories-h)
#+end_src
*** Guess mode on save
#+begin_src emacs-lisp
  (defun my/guess-mode-h ()
    "Guess major mode when saving a file in `fundamental-mode'.

  Likely, something has changed since the buffer was opened. e.g. A shebang line
  or file path may exist now."
    (when (eq major-mode 'fundamental-mode)
      (let ((buffer (or (buffer-base-buffer) (current-buffer))))
        (and (buffer-file-name buffer)
             (eq buffer (window-buffer (selected-window)))
             (set-auto-mode)
             (not (eq major-mode 'fundamental-mode))))))

  (add-hook 'after-save-hook #'my/guess-mode-h)
#+end_src
*** Tramp
#+begin_src emacs-lisp
  (use-package tramp
    :defer t
    :custom
    (remote-file-name-inhibit-cache 60))
#+end_src
** Formatting/Display
*** Indentation
#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil
                tab-width 4)
#+end_src
#+begin_src emacs-lisp
  (setq-default tab-always-indent nil)
#+end_src
#+begin_src emacs-lisp
  (setq tabify-regexp "^\t* [ \t]+")
#+end_src
*** Wrapping
#+begin_src emacs-lisp
  (setq-default truncate-lines t
                truncate-partial-width-windows nil)
#+end_src

#+begin_src emacs-lisp
  (setq-default word-wrap t)
#+end_src

#+begin_src emacs-lisp
  (add-hook 'text-mode-hook #'visual-line-mode)
#+end_src
*** Sentences
#+begin_src emacs-lisp
  (setq sentence-end-double-space nil)
#+end_src
*** Fill column
#+begin_src emacs-lisp
  (setq-default fill-column 80)
#+end_src
*** EOF newlines
#+begin_src emacs-lisp
  (setq require-final-newline t)
#+end_src
*** Whitespace
**** Emacs
#+begin_src emacs-lisp
(setq whitespace-line-column nil
      whitespace-style
      '(face indentation tabs tab-mark spaces space-mark newline newline-mark
        trailing lines-tail))
#+end_src
**** ws-butler
#+begin_src emacs-lisp
  (use-package ws-butler
    :ensure t
    :hook ((prog-mode text-mode) . ws-butler-mode))
#+end_src

*** Highlight matching parens
#+begin_src emacs-lisp
(use-package paren
  :hook ((text-mode prog-mode) . show-paren-mode)
  :config
  (setq show-paren-delay 0.1
        show-paren-highlight-openparen t
        show-paren-when-point-inside-paren t
        show-paren-when-point-in-periphery t))
#+end_src
*** Image
#+begin_src emacs-lisp
  (setq image-animate-loop t)
#+end_src
*** Line numbers
#+begin_src emacs-lisp
  (setq-default display-line-numbers-width 3
                display-line-numbers-widen t
                display-line-numbers-type 'relative)

  (add-hook 'prog-mode-hook #'display-line-numbers-mode)
  (add-hook 'text-mode-hook #'display-line-numbers-mode)
  (add-hook 'conf-mode-hook #'display-line-numbers-mode)
#+end_src
** Behavior
*** better-jumper
#+begin_src emacs-lisp
  (use-package better-jumper
    :ensure t
    :commands my/set-jump-a my/set-jump-maybe-a my/set-jump-h
    :preface
    ;; REVIEW Suppress byte-compiler warning spawning a *Compile-Log* buffer at
    ;; startup. This can be removed once gilbertw1/better-jumper#2 is merged.
    (defvar better-jumper-local-mode nil)
    ;; REVIEW: Remove if/when gilbertw1/better-jumper#26 is addressed.
    (defvaralias 'evil--jumps-jump-command 'evil--jumps-jumping-backward)
    :init
    (global-set-key [remap evil-jump-forward]  #'better-jumper-jump-forward)
    (global-set-key [remap evil-jump-backward] #'better-jumper-jump-backward)
    (global-set-key [remap xref-pop-marker-stack] #'better-jumper-jump-backward)
    (global-set-key [remap xref-go-back] #'better-jumper-jump-backward)
    (global-set-key [remap xref-go-forward] #'better-jumper-jump-forward)
    :config
    (better-jumper-mode)
    (defun my/set-jump-a (fn &rest args)
      "Set a jump point and ensure fn doesn't set any new jump points."
      (better-jumper-set-jump (if (markerp (car args)) (car args)))
      (let ((evil--jumps-jumping t)
            (better-jumper--jumping t))
        (apply fn args)))

    (defun my/set-jump-maybe-a (fn &rest args)
      "Set a jump point if fn actually moves the point."
      (let ((origin (point-marker))
            (result
             (let* ((evil--jumps-jumping t)
                    (better-jumper--jumping t))
               (apply fn args)))
            (dest (point-marker)))
        (unless (equal origin dest)
          (with-current-buffer (marker-buffer origin)
            (better-jumper-set-jump
             (if (markerp (car args))
                 (car args)
               origin))))
        (set-marker origin nil)
        (set-marker dest nil)
        result))

    (defun my/set-jump-h ()
      "Run `better-jumper-set-jump' but return nil, for short-circuiting hooks."
      (when (get-buffer-window)
        (better-jumper-set-jump))
      nil)

    (add-hook 'kill-buffer-hook #'my/set-jump-h)
    (advice-add #'imenu :around #'my/set-jump-a))
#+end_src

*** =direnv= & =envrc=
#+begin_src emacs-lisp
  (use-package direnv
    :ensure t
    :hook prog-mode)

  (use-package envrc
    :ensure t
    :hook prog-mode)
#+end_src

*** kill-ring
*** Minibuffer
#+begin_src emacs-lisp
  (setq enable-recursive-minibuffers t)
  (setq echo-keystrokes 0.02)
#+end_src
#+begin_src emacs-lisp
  (setq minibuffer-prompt-properties '(read-only t intangible t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
#+end_src
*** recentf
#+begin_src emacs-lisp
  (use-package recentf
    :commands recentf-open-files
    :custom
    (recentf-max-saved-items 512))
#+end_src

*** savehist
#+begin_src emacs-lisp
  (use-package savehist
    :hook after-init)
#+end_src

*** smartparens
#+begin_src emacs-lisp
  (use-package smartparens
    :ensure t
    :hook (after-init . smartparens-global-mode)
    :commands sp-pair sp-local-pair sp-with-modes sp-point-in-comment sp-point-in-string
    :config
    (add-to-list 'sp-lisp-modes 'sly-mrepl-mode)
    (require 'smartparens-config)
    (setq sp-highlight-pair-overlay nil
          sp-highlight-wrap-overlay nil
          sp-highlight-wrap-tag-overlay nil)
    (with-eval-after-load 'evil
      (setq sp-show-pair-from-inside t
            sp-cancel-autoskip-on-backward-movement nil
            sp-pair-overlay-keymap (make-sparse-keymap)))

    (setq sp-max-prefix-length 25
          sp-max-pair-length 4)

    ;; Silence some harmless but annoying echo-area spam
    (dolist (key '(:unmatched-expression :no-matching-tag))
      (setf (alist-get key sp-message-alist) nil))

    (defun my/init-smartparens-in-eval-expression-h ()
      "Enable `smartparens-mode' in the minibuffer for `eval-expression'.
  This includes everything that calls `read--expression', e.g.
  `edebug-eval-expression' Only enable it if
  `smartparens-global-mode' is on."
      (when smartparens-global-mode (smartparens-mode +1)))

    (add-hook 'eval-expression-minibuffer-setup-hook
              #'my/init-smartparens-in-eval-expression-h)

    (defun my/init-smartparens-in-minibuffer-maybe-h ()
      "Enable `smartparens' for non-`eval-expression' commands.
  Only enable `smartparens-mode' if `smartparens-global-mode' is
  on."
      (when (and smartparens-global-mode (memq this-command '(evil-ex)))
        (smartparens-mode +1)))
    (add-hook 'minibuffer-setup-hook
              #'my/init-smartparens-in-minibuffer-maybe-h)

    (sp-local-pair '(minibuffer-mode minibuffer-inactive-mode) "'" nil :actions nil)
    (sp-local-pair '(minibuffer-mode minibuffer-inactive-mode) "`" nil :actions nil)

    (defvar my/buffer-smartparens-mode nil)

    (defun my/enable-smartparens-mode-maybe-h ()
      (when my/buffer-smartparens-mode
        (turn-on-smartparens-mode)
        (kill-local-variable 'doom-buffer-smartparens-mode)))
    (add-hook 'evil-replace-state-exit-hook
              #'my/enable-smartparens-mode-maybe-h)

    (defun my/disable-smartparens-mode-maybe-h ()
      (when smartparens-mode
        (setq-local my/buffer-smartparens-mode t)
        (turn-off-smartparens-mode)))
    (add-hook 'evil-replace-state-entry-hook
              #'my/disable-smartparens-mode-maybe-h))
#+end_src

*** which-key
#+begin_src emacs-lisp
    (use-package which-key
      :hook (after-init . which-key-mode)
      :custom
      (which-key-sort-order #'which-key-key-order-alpha)
      (which-key-sort-uppercase-first nil)
      (which-key-add-column-padding 1)
      (which-key-max-display-columns nil)
      (which-key-min-display-lines 6)
      (which-key-side-window-slot -10)
      (which-key-idle-delay 0.3)
      (which-key-idle-secondary-delay 0.1)

      :config
      (which-key-add-key-based-replacements my/leader-key "<leader>")
      (which-key-add-key-based-replacements my/localleader-key "<localleader>"))
#+end_src

*** Yes/No prompts
#+begin_src emacs-lisp
  (setq use-short-answers t)
  (define-key y-or-n-p-map " " nil)
#+end_src
*** Kill ring
#+begin_src emacs-lisp
  (setq kill-do-not-save-duplicates t)
#+end_src
* Evil
** Base
#+begin_src emacs-lisp
  (defvar evil-want-keybinding nil)
  (defvar evil-want-C-g-bindings t)
  (defvar evil-want-C-i-jump t)
  (defvar evil-want-C-u-scroll t)  ; moved the universal arg to <leader> u
  (defvar evil-want-C-u-delete t)
  (defvar evil-want-C-w-delete t)
  (defvar evil-want-Y-yank-to-eol t)
  (defvar evil-want-abbrev-expand-on-insert-exit nil)
  (defvar evil-respect-visual-line-mode nil)
  (use-package evil
    :ensure t
    :defer 0.1
    :preface
    (setq evil-ex-search-vim-style-regexp t
          evil-ex-visual-char-range t
          evil-symbol-word-search t
          evil-normal-state-cursor 'box
          evil-emacs-state-cursor  'box
          evil-insert-state-cursor 'bar
          evil-visual-state-cursor 'hollow
          evil-ex-interactive-search-highlight 'selected-window
          evil-kbd-macro-suppress-motion-error t)

    :config
    (evil-mode 1)
    (evil-select-search-module 'evil-search-module 'evil-search))
#+end_src
** =evil-collection=
#+begin_src emacs-lisp
  (use-package evil-collection
    :ensure t
    :after evil
    :config
    (evil-collection-init))
#+end_src
** =evil-snipe=
Better 1/2 character movements
#+begin_src emacs-lisp
  (use-package evil-snipe
    :ensure t
    :after evil
    :defer 0.1
    :config
    (evil-snipe-mode +1)
    (evil-snipe-override-mode +1)
    :custom
    (evil-snipe-scope 'buffer)        ; Search in whole buffer instead of just line
    (evil-snipe-repeat-scope 'buffer) ; Same for repeat
    (evil-snipe-smart-case t)         ; Smart case sensitivity
    )
#+end_src
** =evil-easymotion=
#+begin_src emacs-lisp
  (use-package evil-easymotion
    :ensure t
    :after (evil-snipe)
    :config
    (general-define-key
     :states '(motion)
     :prefix "C-;"
     :prefix-map 'evilem-map)
    (general-define-key
     :keymaps 'evil-snipe-parent-transient-map
     "C-;" (evilem-create
            'evil-snipe-repeat
            :bind
            ((evil-snipe-scope 'buffer)
             (evil-snipe-enable-highlight)
             (evil-snipe-enable-incremental-highlight)))))
#+end_src
** evil-nerd-commenter
#+begin_src emacs-lisp
  (use-package evil-nerd-commenter
    :ensure t
    :after evil
    :commands (evilnc-comment-operator
               evilnc-inner-comment
               evilnc-outer-commenter)
    :general ([remap comment-line] #'evilnc-comment-or-uncomment-lines))
#+end_src
** evil-surround
#+begin_src emacs-lisp
    (use-package evil-surround
      :ensure t
      :hook ((prog-mode text-mode) . global-evil-surround-mode)
      :commands (global-evil-surround-mode
                 evil-surround-edit
                 evil-Surround-edit
                 evil-surround-region))
#+end_src

** evil-textobj-anyblock
#+begin_src emacs-lisp
  (use-package evil-textobj-anyblock
    :ensure t
    :after evil
    :config
    (setq evil-textobj-anyblock-blocks
          '(("(" . ")")
            ("{" . "}")
            ("\\[" . "\\]")
            ("<" . ">"))))
#+end_src

** exato
#+begin_src emacs-lisp
  (use-package exato
    :ensure t
    :after evil
    :commands evil-outer-xml-attr evil-inner-xml-attr)
#+end_src

* Completion
** Corfu
#+begin_src emacs-lisp
  (use-package corfu
    :ensure t
    :defer 0.1
    :custom
    (corfu-cycle t)
    (corfu-auto t)
    (corfu-auto-delay 0.24)
    (corfu-auto-prefix 2)
    (corfu-preselect 'prompt)
    (corfu-quit-at-boundary t)
    (corfu-count 16)
    (corfu-max-width 120)
    (corfu-on-exact-match nil)
    (corfu-quit-at-boundary 'separator)
    (corfu-quit-no-match corfu-quit-at-boundary)
    (tab-always-indent 'complete)
    (global-corfu-modes '((not erc-mode
                               help-mode
                               vterm-mode)
                          t))
    (global-corfu-minibuffer t)


    :config
    (global-corfu-mode)
    (add-to-list 'completion-category-overrides `(lsp-capf (styles ,@completion-styles)))

    (add-hook 'evil-insert-state-exit-hook #'corfu-quit)
    (general-def
      :keymaps 'corfu-map
      "SPC" 'corfu-insert-separator
      "TAB" 'corfu-next
      "S-TAB" 'corfu-previous))

  (use-package corfu-popupinfo
    :after corfu
    :hook (corfu-mode . corfu-popupinfo-mode)
    :custom
    (corfu-popupinfo-delay '(0.2 . 0.2)))
#+end_src

#+begin_src emacs-lisp
  (defun my/corfu--dabbrev-or-last (&optional arg)
    "Trigger corfu popup and select the first candidate.

  Intended to mimic `evil-complete-previous', unless the popup is already open."
    (interactive "p")
    (if corfu--candidates
        (corfu-previous arg)
      (require 'cape)
      (let ((cape-dabbrev-check-other-buffers
             (bound-and-true-p evil-complete-all-buffers)))
        (cape-dabbrev t)
        (when (> corfu--total 0)
          (corfu--goto (- corfu--total (or arg 1)))))))

(defun my/corfu--dabbrev-or-next (&optional arg)
  "Trigger corfu popup and select the first candidate.

Intended to mimic `evil-complete-next', unless the popup is already open."
  (interactive "p")
  (if corfu--candidates
      (corfu-next arg)
    (require 'cape)
    (let ((cape-dabbrev-check-other-buffers
           (bound-and-true-p evil-complete-all-buffers)))
      (cape-dabbrev t)
      (when (> corfu--total 0)
        (corfu--goto (or arg 0))))))
#+end_src
** Cape
#+begin_src emacs-lisp
  (use-package cape
    :ensure t
    :init
    (general-def "C-c p" 'cape-prefix-map)
    (add-hook 'completion-at-point-functions #'cape-dabbrev)
    (add-hook 'completion-at-point-functions #'cape-keyword)
    (add-hook 'completion-at-point-functions #'cape-file)

    (advice-add #'comint-completion-at-point :around #'cape-wrap-nonexclusive)
    (advice-add #'eglot-completion-at-point :around #'cape-wrap-nonexclusive)
    (advice-add #'pcomplete-completions-at-point :around #'cape-wrap-nonexclusive))
#+end_src
** Vertico
#+begin_src emacs-lisp
  (use-package vertico
    :ensure t
    :custom
    (vertico-cycle t)
    (vertico-count 20)
    (vertico-resize t)

    :config
    (vertico-mode)
    (general-def
      :keymaps 'vertico-map
      "M-j" 'next-line
      "M-k" 'previous-line
      "M-h" 'backward-paragraph
      "M-l" 'forward-paragraph)

    ;; Prompt indicator for `completing-read-multiple'.
    (when (< emacs-major-version 31)
      (advice-add #'completing-read-multiple :filter-args
                  (lambda (args)
                    (cons (format "[CRM%s] %s"
                                  (string-replace "[ \t]*" "" crm-separator)
                                  (car args))
                          (cdr args))))))

  (require 'vertico-buffer)
  (require 'vertico-grid)
  (require 'vertico-directory)
  (require 'vertico-reverse)
  (require 'vertico-repeat)
  (require 'vertico-multiform)

  (add-hook 'rfn-esm-update-handlers #'vertico-directory-tidy)

  (general-def
    :keymaps '(vertico-map vertico-mulltiform-map)
    "RET" 'vertico-directory-enter
    "DEL" 'vertico-directory-delete-char
    "M-DEL" 'vertico-directory-delete-word)

  (setq vertico-buffer-display-action '(display-buffer-use-least-recent-window)
        vertico-multiform-categories '((embark-keybinding grid)))

  (vertico-multiform-mode)

  (add-hook 'minibuffer-setup-hook #'vertico-repeat-save)

  (general-def
    :states '(normal insert visual motion)
    "C-M-;" 'vertico-repeat)

  (advice-add #'ffap-menu-ask :around
              (lambda (&rest args)
                (cl-letf (((symbol-function #'minibuffer-completion-help)
                           #'ignore))
                  (apply args))))
#+end_src
** Orderless
#+begin_src emacs-lisp
  (use-package orderless
    :ensure t
    :config
    (defun my/vertico--company-capf--candidates-a (fn &rest args)
      "Highlight company matches correctly, and try default completion styles before
  orderless."
      (let ((orderless-match-faces [completions-common-part])
            (completion-styles '(basic partial-completion orderless)))
        (apply fn args)))
    (advice-add 'company-capf--candidates :around #'my/vertico--company-capf--candidates-a)

    (setq orderless-affix-dispatch-alist
          '((?! . orderless-without-literal)
            (?& . orderless-annotation)
            (?% . char-fold-to-regexp)
            (?` . orderless-initialism)
            (?= . orderless-literal)
            (?^ . orderless-literal-prefix)
            (?~ . orderless-flex)))

    (setq completion-styles '(orderless basic)
          completion-category-defaults nil
          ;; note that despite override in the name orderless can still be used in
          ;; find-file etc.
          completion-category-overrides '((file (styles orderless partial-completion)))
          orderless-component-separator #'orderless-escapable-split-on-space)
    ;; ...otherwise find-file gets different highlighting than other commands
    (set-face-attribute 'completions-first-difference nil :inherit nil))
#+end_src
** Consult
#+begin_src emacs-lisp
   (use-package consult
     :ensure t
     :after (evil vertico)

     :preface
     (general-def
       [remap bookmark-jump]                 #'consult-bookmark
       [remap evil-show-marks]               #'consult-mark
       [remap evil-show-registers]           #'consult-register
       [remap goto-line]                     #'consult-goto-line
       [remap imenu]                         #'consult-imenu
       [remap Info-search]                   #'consult-info
       [remap list-dir]                      #'consult-dir
       [remap locate]                        #'consult-locate
       [remap load-theme]                    #'consult-theme
       [remap recentf-open-files]            #'consult-recent-file
       [remap switch-to-buffer]              #'consult-buffer
       [remap switch-to-buffer-other-window] #'consult-buffer-other-window
       [remap switch-to-buffer-other-frame]  #'consult-buffer-other-frame
       [remap yank-pop]                      #'consult-yank-pop)
       :init
       (advice-add #'register-preview :override #'consult-register-window)
       (setq register-preview-delay 0.5)

       (setq xref-show-xrefs-function #'consult-xref
             xref-show-definitions-function #'consult-xref)

       :config
       (consult-customize
        consult-theme :preview-key '(:debounce 0.1 any)
        consult-ripgrep consult-git-grep consult-grep consult-man
        consult-bookmark consult-recent-file consult-xref
        consult--source-bookmark consult--source-file-register
        consult--source-recent-file consult--source-project-recent-file
        :preview-key '(:debounce 0.3 any))

       (setq consult-narrow-key "<"
             consult-line-numbers-width t
             consult-async-min-input 2
             consult-async-refresh-delay  0.15
             consult-async-input-throttle 0.2
             consult-async-input-debounce 0.1)

       (setq evil-jumps-cross-buffers nil)
       (evil-set-command-property 'consult-line :jump t)
       (general-def
         :keymaps 'vertico-map
         "C-x C-d" #'consult-dir
         "C-x C-j" #'consult-dir-jump-file)

       (consult-customize
        consult-ripgrep consult-git-grep consult-grep
        consult-bookmark consult-recent-file
        consult--source-recent-file consult--source-project-recent-file consult--source-bookmark
        :preview-key "C-SPC"))
#+end_src

** Marginalia
#+begin_src emacs-lisp
  (use-package marginalia
    :ensure t
    :init
    (marginalia-mode)
    :custom
    (marginalia-max-relative-age 0)
    :config
    (add-to-list 'marginalia-prompt-categories '("\\<face\\>" . face))
    (add-to-list 'marginalia-prompt-categories '("\\<var\\>" . variable)))
#+end_src
* Magit
#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :commands (magit magit-dispatch)
    :custom
    (magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
    (magit-bury-buffer-function #'magit-restore-window-configuration)
    (magit-save-repository-buffers 'dontask)
    (magit-no-confirm '(stage-all-changes unstage-all-changes)))
#+end_src

* Keys
#+begin_src emacs-lisp
  (use-package general
    :ensure t
    :after (evil)
    :config
    (general-evil-setup))
#+end_src

#+begin_src emacs-lisp
  (defvar my/leader-key "SPC")
  (defvar my/leader-alt-key "M-SPC")
  (defvar my/leader-key-states '(normal visual motion))
  (defvar my/leader-alt-key-states '(emacs insert))
  (defvar my/localleader-key "SPC m")
  (defvar my/localleader-alt-key "M-SPC m")
#+end_src

#+begin_src emacs-lisp
  (defvar my/leader-map (make-sparse-keymap))
  (defvar my/localleader-map (make-sparse-keymap))
#+end_src

#+begin_src emacs-lisp
    (define-prefix-command 'my/leader 'my/leader-map)

    (general-define-key
     :keymaps 'general-override-mode-map
     :states my/leader-key-states
     my/leader-key 'my/leader)

    (general-define-key
     :keymaps 'general-override-mode-map
     :states my/leader-alt-key-states
     my/leader-alt-key 'my/leader)

    (general-override-mode +1)

    (general-define-key
     :prefix-command 'my/file-prefix
     "f" '("Find file" . find-file)
     "d" '("Find directory". dired)
     "l" '("Locate files" . locate)
     "r" '("Recent files" . recentf-open-files))

    (general-define-key
     :prefix-command 'my/search-prefix
     "s" '("Search buffer" . consult-line)
     "L" '("Jump to link" . ffap-menu)
     "p" '("Search project" . consult-ripgrep)
     "i" '("imenu" . imenu))

    (general-define-key
     :prefix-command 'my/buffer-prefix
     "," '("Switch buffer" . switch-to-buffer)
     "d" '("Kill current buffer" . kill-current-buffer)
     "i" '("ibuffer" . ibuffer)
     "l" '("Switch to last buffer" . evil-switch-to-windows-last-buffer)
     "m" '("Set bookmark" . bookmark-set)
     "d" '("Delete bookmark" . bookmark-delete)
     "r" '("Revert buffer" . revert-buffer))

    (general-define-key
     :states nil
     :keymaps 'my/leader-map
     "'" '("Repeat last search" . vertico-repeat)
     "u" '("Universal argument" . universal-argument)
     ";" '("Eval expression" . pp-eval-expression)
     ":" '("M-x" . execute-extended-command)
     "," '("Switch buffer" . switch-to-buffer)
     "." '("Find file" . find-file)
     "SPC" '("Find file in project" . projectile-find-file)
     "RET" '("Jump to bookmark" . bookmark-jump)
     "p" (cons "projectile" 'projectile-command-map)
     "h" (cons "help" help-map)
     "w" (cons "window" 'evil-window-map)
     "b" '("buffer" . my/buffer-prefix)
     "f" '("file" . my/file-prefix)
     "s" '("search" . my/search-prefix))
#+end_src

#+begin_src emacs-lisp
  (general-define-key
   :keymaps 'corfu-mode-map
   :states '(insert)
   "C-@" 'completion-at-point
   "C-SPC" 'completion-at-point
   "C-n" 'my/corfu--dabbrev-or-next
   "C-p" 'my/corfu--dabbrev-or-last)
  (general-define-key
   :keymaps 'corfu-mode-map
   :states '(normal)
   "C-SPC" (lambda () (interactive)
             (call-interactively #'evil-insert-state)
             (call-interactively #'completion-at-point)))
  (general-define-key
   :keymaps 'corfu-mode-map
   :states '(visual)
   "C-SPC" (lambda () (interactive)
             (call-interactively #'evil-change-state)
             (call-interactively #'completion-at-point)))
  (general-define-key
   :keymaps 'corfu-map
   :states '(insert)
   "C-SPC" 'corfu-insert-separator)
  (general-define-key
   :keymaps 'corfu-map
   "C-k" 'corfu-previous
   "C-j" 'corfu-next
   "C-u" (lambda () (interactive)
           (let (curfu-cycle)
             (funcall-interactively #'corfu-next (- corfu-count))))
   "C-d" (lambda () (interactive)
           (let (curfu-cycle)
             (funcall-interactively #'corfu-next corfu-count))))

  (general-define-key
   :keymaps 'corfu-popupinfo-map
   "C-h" 'corfu-popupinfo-toggle
   "C-S-k" #'corfu-popupinfo-scroll-down
   "C-S-j" #'corfu-popupinfo-scroll-up
   "C-<up>" #'corfu-popupinfo-scroll-down
   "C-<down>" #'corfu-popupinfo-scroll-up
   "C-S-p" #'corfu-popupinfo-scroll-down
   "C-S-n" #'corfu-popupinfo-scroll-up
   "C-S-u" (lambda () (interactive)
             (corfu-popupinfo-scroll-down nil corfu-popupinfo-min-height))
   "C-S-d" (lambda () (interactive)
             (corfu-popupinfo-scroll-up nil corfu-popupinfo-min-height)))
#+end_src

* Server
#+begin_src emacs-lisp
  (defun my/maybe-start-server ()
    (require 'server)
    (unless (server-running-p)
      (message "Starting server")
      (server-start)))

  (use-package server
    :hook (after-init . my/maybe-start-server)
    :if (display-graphic-p))
#+end_src
