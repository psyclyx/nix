#+TITLE: Emacs configuration
#+AUTHOR: psyclyx
#+PROPERTY: header-args:emacs-lisp :lexical t
#+STARTUP: content

* Base
#+begin_src emacs-lisp
    (require 'json)
    (require 'url)
#+end_src
** Disable GC
#+begin_src emacs-lisp
  ;; startup
  (setq gc-cons-threshold most-positive-fixnum ; 2^61 bytes
        gc-cons-percentage 0.6)

  (defvar my/file-name-handler-alist-cache file-name-handler-alist)

  (setq file-name-handler-alist nil)

  (defun my/restore-post-init-settings ()
    (setq gc-cons-threshold  (* 128 1024 1024) ; 128mb
          gc-cons-percentage 0.1)
    (setq file-name-handler-alist my/file-name-handler-alist-cache))

  (add-hook 'emacs-startup-hook #'my/restore-post-init-settings)
#+end_src
** Declutter
#+begin_src emacs-lisp
  (setq create-lockfiles nil)

  (setq custom-file (expand-file-name "custom.el" "~/.local/state/emacs/"))

  (when (file-exists-p custom-file)
    (load custom-file))

  (use-package no-littering
    :config
    (setq auto-save-file-name-transforms
          `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))
    (setq backup-directory-alist
          `(("." . ,(no-littering-expand-var-file-name "backup/"))))

    ;; Keep transient files organized
    (setq transient-history-file (no-littering-expand-var-file-name "transient/history.el")
          transient-levels-file (no-littering-expand-etc-file-name "transient/levels.el")
          transient-values-file (no-littering-expand-etc-file-name "transient/values.el")))
#+end_src
** Config reload
#+begin_src emacs-lisp
  (defun my/reload-config ()
    "Reload the literate config."
    (interactive)
    (org-babel-load-file (expand-file-name "~/projects/nix/modules/home/programs/emacs/config.org")))
#+end_src
** Exec path
On darwin, I often launch =Emacs.app= instead of =emacs=. However, MacOS
sets a default environment that doesn't include anything configured through
home-manager. =exec-path-from-shell= fixes this by +stealing+ borrowing what's
set in a non-interactive shell.

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :custom
    (exec-path-from-shell-argument nil)
    :init
    (exec-path-from-shell-initialize))
 #+end_src
* Interface
** Pixelwise sizing
#+begin_src emacs-lisp
  (setq frame-resize-pixelwise t
        window-resize-pixelwise t)
#+end_src
** Simplify UI
#+begin_src emacs-lisp
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (tooltip-mode -1)
  (setq inhibit-startup-message t)
#+end_src
** Relative line numbers
#+begin_src emacs-lisp
  (setq display-line-numbers-type 'relative)
  (global-display-line-numbers-mode 1)
#+end_src
** `visual-line-mode`
#+begin_src emacs-lisp
  (global-visual-line-mode 1)
#+end_src
** Show whitespace
#+begin_src emacs-lisp
  ;; Show meaningful whitespace
  (setq whitespace-style '(face indentation trailing)
        whitespace-global-modes '(not shell-mode
                                      help-mode
                                      magit-mode
                                      magit-diff-mode
                                      ibuffer-mode
                                      dired-mode
                                      occur-mode))

  (global-whitespace-mode 1)
#+end_src
** Font
#+begin_src emacs-lisp

    (set-face-attribute 'default nil
                        :family "NotoMono Nerd Font Mono"
                        :height 160)

    (set-face-attribute 'variable-pitch nil
                        :family "NotoSerif Nerd Font Propo")

    (set-fontset-font t 'unicode (font-spec :family "Symbola"))

    (use-package mixed-pitch
      :hook
      ((org-mode org-roam-mode text-mode) . mixed-pitch-mode))
#+end_src
** Theme (=doom-themes=)
#+begin_src emacs-lisp
  (use-package doom-themes
    :config
    (setq doom-themes-enable-bold t
          doom-themes-enable-italic t)
    (load-theme 'doom-gruvbox-light t)
    (doom-themes-visual-bell-config)
    (doom-themes-org-config))
#+end_src
* Editor
** Recentf
#+begin_src emacs-lisp
  (use-package recentf
    :ensure nil
    :custom
    (recentf-max-saved-items 512)
    :init
    (recentf-mode 1))
#+end_src
** Spaces, not tabs
#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil
                tab-width 4)
#+end_src
** Evil
#+begin_src emacs-lisp
  (use-package evil
    :init
    (setq evil-want-integration t
          evil-want-keybinding nil
          evil-want-C-u-scroll t
          evil-want-C-i-jump t
          evil-undo-system 'undo-tree)
    :config
    (evil-mode 1))
#+end_src
*** Integrations
**** Most modes
#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))
#+end_src
**** =org-mode=
#+begin_src emacs-lisp
  (use-package evil-org
    :after org
    :hook (org-mode . (lambda ()
                        (evil-org-set-key-theme '(navigation insert return textobjects additional shift todo heading calendar))
                        (evil-org-mode)
                        (require 'evil-org-agenda)
                        (evil-org-agenda-set-keys))))
#+end_src
** Fast movement
*** =evil-snipe=
#+begin_src emacs-lisp
  (use-package evil-snipe
    :after evil
    :config
    (evil-snipe-mode +1)
    (evil-snipe-override-mode +1)
    :custom
    (evil-snipe-scope 'buffer)        ; Search in whole buffer instead of just line
    (evil-snipe-repeat-scope 'buffer) ; Same for repeat
    (evil-snipe-smart-case t)         ; Smart case sensitivity
    )
#+end_src
*** =evil-easymotion=
#+begin_src emacs-lisp
  (use-package evil-easymotion
    :after (evil-snipe)
    :config
    (general-define-key
     :states '(motion)
     :prefix "C-;"
     :prefix-map 'evilem-map)
    (general-define-key
     :keymaps 'evil-snipe-parent-transient-map
     "C-;" (evilem-create
            'evil-snipe-repeat
            :bind
            ((evil-snipe-scope 'buffer)
             (evil-snipe-enable-highlight)
             (evil-snipe-enable-incremental-highlight)))))
#+end_src
** =undo-tree=
#+begin_src emacs-lisp
  (use-package undo-tree
    :init
    (global-undo-tree-mode 1)
    :config
    (setq undo-tree-auto-save-history t
          undo-tree-history-directory-alist
          `(("." . ,(no-littering-expand-var-file-name "undo-tree-hist/")))))
#+end_src
** Bindings
*** Leader (=general.el=)
#+begin_src emacs-lisp
  (use-package general
    :config
    (general-evil-setup)

    ;; Create our leader key definer
    (general-create-definer my-leader-def
      :keymaps 'override
      :states '(normal visual insert emacs)
      :prefix "SPC"
      :non-normal-prefix "C-SPC"))
#+end_src
*** Local leader (bindings for major modes)
#+begin_src emacs-lisp
  (general-create-definer my-local-leader-def
    :keymaps 'override
    :states '(normal visual insert emacs)
    :prefix "SPC m"
    :non-normal-prefix "C-SPC m")
#+end_src
*** Quick bindings
#+begin_src emacs-lisp
  (my-leader-def
    "." 'find-file
    "," 'consult-buffer
    "/" 'consult-ripgrep
    ";" 'eval-expression
    ":" 'execute-extended-command)
#+end_src
*** Buffers
#+begin_src emacs-lisp
  (my-leader-def
    :infix "b"
    "b" 'consult-buffer
    "d" 'kill-current-buffer)
#+end_src
*** Files
#+begin_src emacs-lisp
  (my-leader-def
    :infix "f"
    "f" 'find-file
    "r" 'consult-recent-file
    "R" 'my/reload-config)
#+end_src
*** Search
#+begin_src emacs-lisp
  (my-leader-def
    :infix "s"
    "s" 'consult-line
    "S" 'consult-line-multi
    "p" 'consult-ripgrep
    "f" 'consult-find
    "h" 'consult-org-heading
    "m" 'consult-mark
    "i" 'consult-imenu
    "r" 'consult-recent-file
    "g" 'consult-git-grep
    "d" 'consult-dir
    "o" 'consult-outline)
#+end_src
*** Help
#+begin_src emacs-lisp
  (my-leader-def "h" 'help-command)
#+end_src
*** Toggle
#+begin_src emacs-lisp
  (my-leader-def "S" 'global-text-scale-adjust)
#+end_src
* Completion
** Matching (=orderless=)
#+begin_src emacs-lisp
  (use-package orderless
    :custom
    (completion-styles '(orderless basic))
    (completion-category-overrides '((file (styles . (partial-completion basic)))
                                   (project-file (styles . (partial-completion basic)))))
    :config
    ;; Recognize more completion styles
    (setq orderless-matching-styles
          '(orderless-literal
            orderless-prefixes
            orderless-initialism
            orderless-regexp)))
#+end_src
** Minibuffer
#+begin_src emacs-lisp
  (general-setq enable-recursive-minibuffers t)

  (minibuffer-depth-indicate-mode)

  (general-setq minibuffer-prompt-properties
         '(read-only t face minibuffer-prompt intangible t cursor-intangible t))
  (general-add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

  (defun helper:kill-minibuffer ()
    "Exit the minibuffer if it is active."
    (when (and (>= (recursion-depth) 1)
               (active-minibuffer-window))
      (abort-recursive-edit)))

  (general-add-hook 'mouse-leave-buffer-hook #'helper:kill-minibuffer)
#+end_src

*** Menu (=vertico=)
#+begin_src emacs-lisp
  (use-package vertico
    :init
    (vertico-mode)

    :custom
    (vertico-cycle t)
    (vertico-count 15)
    (vertico-resize t))

  ;; Persist history over Emacs restarts
  (use-package savehist
    :init
    (savehist-mode))

  ;; Directory navigation like ido
  (use-package vertico-directory
    :after vertico
    :ensure nil
    :bind (:map vertico-map
                ("RET" . vertico-directory-enter)
                ("DEL" . vertico-directory-delete-char)
                ("M-DEL" . vertico-directory-delete-word))
    :hook (rfn-esm-update-handlers . vertico-directory-tidy))
#+end_src
*** Annotations (=marginalia=)
#+begin_src emacs-lisp
  (use-package marginalia
    :after vertico
    :init
    (marginalia-mode)
    :custom
    (marginalia-align 'right)
    (marginalia-max-relative-age 0)
    :config
    ;; Add custom annotators for more informative completions
    (add-to-list 'marginalia-prompt-categories '("\\<face\\>" . face))
    (add-to-list 'marginalia-prompt-categories '("\\<var\\>" . variable)))
#+end_src
** In-buffer (=corfu=)
#+begin_src emacs-lisp
  (use-package corfu
    :custom
    (corfu-cycle t)
    (corfu-auto t)
    (corfu-auto-delay 0.3)
    (corfu-auto-prefix 2)
    (corfu-preselect 'prompt)
    (corfu-quit-at-boundary nil)
    (read-extended-command-predicate #'command-completion-default-include-p)

    :init
    (global-corfu-mode)

    :config
    (general-def
      :keymaps 'corfu-map
      "SPC" 'corfu-insert-separator
      "TAB" 'corfu-next
      "S-TAB" 'corfu-previous))


  (use-package corfu-popupinfo
    :after corfu
    :hook (corfu-mode . corfu-popupinfo-mode)
    :custom
    (corfu-popupinfo-delay '(0.4 . 0.2)))
#+end_src
** At point (=cape=)
#+begin_src emacs-lisp
  (use-package cape
    :init
    (add-to-list 'completion-at-point-functions #'cape-dabbrev)
    (add-to-list 'completion-at-point-functions #'cape-keyword)
    (add-to-list 'completion-at-point-functions #'cape-file)

    (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-silent)
    (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-purify)

    :config
    (general-def "C-c p" 'cape-prefix-map)

    (setq completion-annotate-function #'cape-annotate-prompt))
#+end_src
** Command menu (=consult=)
#+begin_src emacs-lisp
  (use-package consult
    :after vertico

    :init
    (advice-add #'register-preview :override #'consult-register-window)
    (setq register-preview-delay 0.5)

    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    :config
    (consult-customize
     consult-theme :preview-key '(:debounce 0.1 any)
     consult-ripgrep consult-git-grep consult-grep consult-man
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-file-register
     consult--source-recent-file consult--source-project-recent-file
     :preview-key '(:debounce 0.3 any))

    (setq consult-narrow-key "<")

    (setq evil-jumps-cross-buffers nil)
    (evil-set-command-property 'consult-line :jump t))
#+end_src
** Command discovery (=which-key=)
#+begin_src emacs-lisp
  (use-package which-key
    :init
    (which-key-mode)
    :custom
    (which-key-idle-delay 0.2)
    (which-key-prefix-prefix "+")
    (which-key-sort-order 'which-key-key-order-alpha)
    (which-key-sort-uppercase-first nil)
    (which-key-add-column-padding 1)
    (which-key-max-display-columns nil)
    (which-key-min-display-lines 6)
    :config
    ;; Allow C-h to trigger which-key before it is done automatically
    (setq which-key-show-early-on-C-h t)
    ;; Make sure which-key buffer is always below minibuffer
    (setq which-key-popup-type 'side-window))
#+end_src
** Actions (=embark=)
#+begin_src emacs-lisp
  (use-package embark
    :init
    (setq prefix-help-command #'embark-prefix-help-command)

    :config
    (general-define-key
     :keymaps 'override
     "C-." '(embark-act :which-key "embark-act")
     "S-C-." '(embark-dwim :which-key "embark-dwin")
     "C-h B" '(embark-bindings :which-key "embark bindings"))

    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none)))))

  (use-package embark-consult
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))

  (defun embark-which-key-indicator ()
    "An embark indicator that displays keymaps using which-key.
  The which-key help message will show the type and value of the
  current target followed by an ellipsis if there are further
  targets."
    (lambda (&optional keymap targets prefix)
      (if (null keymap)
          (which-key--hide-popup-ignore-command)
        (which-key--show-keymap
         (if (eq (plist-get (car targets) :type) 'embark-become)
             "Become"
           (format "Act on %s '%s'%s"
                   (plist-get (car targets) :type)
                   (embark--truncate-target (plist-get (car targets) :target))
                   (if (cdr targets) "…" "")))
         (if prefix
             (pcase (lookup-key keymap prefix 'accept-default)
               ((and (pred keymapp) km) km)
               (_ (key-binding prefix 'accept-default)))
           keymap)
         nil nil t (lambda (binding)
                     (not (string-suffix-p "-argument" (cdr binding))))))))

  (setq embark-indicators
        '(embark-which-key-indicator
      embark-highlight-indicator
      embark-isearch-highlight-indicator))

  (defun embark-hide-which-key-indicator (fn &rest args)
    "Hide the which-key indicator immediately when using the completing-read prompter."
    (which-key--hide-popup-ignore-command)
    (let ((embark-indicators
           (remq #'embark-which-key-indicator embark-indicators)))
      (apply fn args)))

  (advice-add #'embark-completing-read-prompter
              :around #'embark-hide-which-key-indicator)
#+end_src
* Development
** Highlight matching parentheses (=rainbow-delimiters=)
#+begin_src emacs-lisp
  (use-package rainbow-delimiters)
#+end_src
** LSP (=eglot=)
#+begin_src emacs-lisp
  (use-package eglot
    :custom
    (eglot-autoshutdown t)
    (eglot-events-buffer-size 0)
    (eglot-sync-connect nil)
    (eglot-connect-timeout 300)
    (eglot-auto-display-help-buffer nil)

    :config
    (my-leader-def
      :infix "l"
      "l" 'eglot
      "r" 'eglot-reconnect
      "s" 'eglot-shutdown))
#+end_src
** Syntax checking (=flycheck=)
#+begin_src emacs-lisp
  (use-package flycheck
    :custom
    (flycheck-display-errors-delay 0.1)
    (flycheck-indication-mode 'left-margin)

    :config
    (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
    (my-leader-def
      :infix "e"
      "l" 'flycheck-list-errors
      "n" 'flycheck-next-error
      "p" 'flycheck-previous-error
      "b" 'flycheck-buffer))
#+end_src
** Structural Editing (=lispy= and =lispyville=)
#+begin_src emacs-lisp
  (use-package lispy
    :hook ((emacs-lisp-mode
            lisp-mode
            scheme-mode
            clojure-mode) . lispy-mode)
    :custom
    (lispy-close-quotes-at-end-p t)
    (lispy-colon-p nil))

  (use-package lispyville
    :after (evil lispy)
    :hook (lispy-mode . lispyville-mode)
    :config
    (general-create-definer my/lispyville-define-key
      :keymaps 'lispyville-mode-map)

    ;; operators
    (my/lispyville-define-key
      [remap evil-yank] 'lispyville-yank
      [remap evil-delete] 'lispyville-delete
      [remap evil-change] 'lispyville-change
      [remap evil-yank-line] 'lispyville-yank-line
      [remap evil-delete-line] 'lispyville-delete-line
      [remap evil-change-line] 'lispyville-change-line
      [remap evil-delete-char] 'lispyville-delete-char-or-splice
      [remap evil-delete-backward-char] 'lispyville-delete-char-or-splice-backwards
      [remap evil-substitute] 'lispyville-substitute
      [remap evil-change-whole-line] 'lispyville-change-whole-line
      [remap evil-join] 'lispyville-join)

    ;; c-w
    (my/lispyville-define-key
      [remap evil-delete-backward-word] 'lispyville-delete-backward-word)

    ;; c-u
    ;; (my/lispyville-define-key
    ;;   [remap evil-delete-back-to-indentation] 'lispyville-delete-back-to-indentation)

    ;; prettify
    (my/lispyville-define-key
      [remap evil-indent] #'lispyville-prettify)

    ;; text-objects
    (my/lispyville-define-key
      :keymaps 'evil-inner-text-objects-map
      "a" 'lispyville-inner-atom
      "l" 'lispyville-inner-list
      "x" 'lispyville-inner-sexp
      "f" 'lispyville-inner-function
      "c" 'lispyville-inner-comment
      "S" 'lispyville-inner-string)

    (my/lispyville-define-key
      :keymaps 'evil-outer-text-objects-map
      "a" 'lispyville-a-atom
      "l" 'lispyville-a-list
      "x" 'lispyville-a-sexp
      "f" 'lispyville-a-function
      "c" 'lispyville-a-comment
      "S" 'lispyville-a-string)

    ;; atom-movements
    (my/lispyville-define-key
      [remap evil-forward-WORD-begin] 'lispyville-forward-atom-begin
      [remap evil-forward-WORD-end] 'lispyville-forward-atom-end
      [remap evil-backward-WORD-begin] 'lispyville-backward-atom-begin
      [remap evil-backward-WORD-end] 'lispyville-backward-atom-end)
    ;; (my/lispyville-define-key
    ;;   [remap evil-forward-word-begin] 'lispyville-forward-atom-begin
    ;;   [remap evil-forward-word-end] 'lispyville-forward-atom-end
    ;;   [remap evil-backward-word-begin] 'lispyville-backward-atom-begin
    ;;   [remap evil-backward-word-end] 'lispyville-backward-atom-end)
    
    ;; additional-movement
    (my/lispyville-define-key
      :states '(motion)
      "H" 'lispyville-backward-sexp
      "L" 'lispyville-forward-sexp
      (kbd "M-h") 'lispyville-beginning-of-defun
      (kbd "M-l") 'lispyville-end-of-defun
      ;; reverse of lispy-flow
      "[" 'lispyville-previous-opening
      "]" 'lispyville-next-closing
      ;; like lispy-flow
      "{" 'lispyville-next-opening
      "}" 'lispyville-previous-closing
      ;; like lispy-left and lispy-right
      "(" 'lispyville-backward-up-list
      ")" 'lispyville-up-list)

    ;; commentary
    (my/lispyville-define-key
      :states '(normal)
      "gc" 'lispyville-comment-or-uncomment
      "gy" 'lispyville-comment-and-clone-dwim
      (kbd "s-/") 'lispyville-comment-or-uncomment-line)

    ;; slurp/barf-cp
    (my/lispyville-define-key
      :states '(normal)
      ">" 'lispyville->
      "<" 'lispyville-<)

    ;; slurp/barf-lispy
    ;; (my/lispyville-define-key
    ;;  :states '(normal)
    ;;  ">" 'lispyville-slurp
    ;;  "<" 'lispyville-barf)

    ;; wrap
    (my/lispyville-define-key
      :states '(normal)
      (kbd "M-(") 'lispyville-wrap-with-round
      (kbd "M-[") 'lispyville-wrap-with-brackets
      (kbd "M-{") 'lispyville-wrap-with-braces)

    ;; additional
    (my/lispyville-define-key
      :states '(normal)
      (kbd "M-j") 'lispyville-drag-forward
      (kbd "M-k") 'lispyville-drag-backward
      (kbd "M-J") 'lispy-join
      (kbd "M-s") 'lispy-splice
      (kbd "M-S") 'lispy-split
      (kbd "M-r") 'lispy-raise-sexp
      (kbd "M-R") 'lispyville-raise-list
      (kbd "M-t") 'transpose-sexps
      (kbd "M-v") 'lispy-convolute-sexp)

    ;; additional-insert
    (my/lispyville-define-key
      :states '(normal)
      (kbd "M-i") 'lispyville-insert-at-beginning-of-list
      (kbd "M-a") 'lispyville-insert-at-end-of-list
      (kbd "M-o") 'lispyville-open-below-list
      (kbd "M-O") 'lispyville-open-above-list)

    ;; additional-wrap
    ;; (my/lispyville-define-key
    ;;  :states '(normal)
    ;;  (kbd "M-(") 'lispyville-wrap-round
    ;;  (kbd "M-[") 'lispyville-wrap-brackets
    ;;  (kbd "M-{") 'lispyville-wrap-braces)

    ;; arrows
    ;; (my/lispyville-define-key
    ;;  :states '(normal)
    ;;  "<i" 'lispyville-insert-at-beginning-of-list
    ;;  ">i" 'lispyville-insert-at-end-of-list)

    ;; insert
    ;; (lispyville-space-after-insert)

    ;;escape
    (my/lispyville-define-key
      :states '(insert emacs)
      (kbd "<escape>") 'lispyville-normal-state)


    ;; mark
    ;; (my/lispyville-define-key
    ;;   :states '(normal visual)
    ;;   "v" (lispyville-wrap-command lispy-mark-symbol visual)
    ;;   "V" (lispyville-wrap-command lispy-mark visual)
    ;;   (kbd "C-v") 'lispyville-wrap-lispy-mark-visual)

    ;; mark-special
    ;; (my/lispyville-define-key
    ;;   :states '(normal visual)
    ;;   "v" (lispyville-wrap-command lispy-mark-symbol special)
    ;;   "V" (lispyville-wrap-command lispy-mark special)
    ;;   (kbd "C-v") 'lispyville-wrap-lispy-mark-special)

    ;; mark-toggle
    ;; (my/lispyville-define-key
    ;;   :states '(visual)
    ;;   "" 'lispyville-toggle-mark-type)

    ;; (my/lispyville-define-key
    ;;   :states '(insert emacs)
    ;;   (kbd "<escape>") 'lispyville-escape)

    (setq lispy-compat '(magit-blame-mode edebug cider)))
#+end_src
** Formatting (=aphelia=)
#+begin_src emacs-lisp
  (use-package apheleia
    :config
    (my-leader-def "=" '(apheleia-format-buffer :which-key "format (apheleia)")))
#+end_src
** Project management (=projectile=)
#+begin_src emacs-lisp
  (use-package projectile
    :init
    (projectile-mode +1)

    :custom
    (projectile-enable-caching t)
    (projectile-globally-ignored-directories
     '(".git" ".log" "tmp" "dist" "*node_modules" ".direnv" "*target" "*.lsp" "*.clj-kondo"))

    :config
    (add-to-list 'projectile-project-root-files "package.json")
    (add-to-list 'projectile-project-root-files "flake.nix")
    (add-to-list 'projectile-project-root-files "shadow-cljs.edn")
    (add-to-list 'projectile-project-root-files "project.clj")
    (add-to-list 'projectile-project-root-files "deps.edn")

    (my-leader-def
      :infix "p"
      "a" 'projectile-add-known-project
      "p" 'projectile-switch-project
      "f" 'projectile-find-file
      "d" 'projectile-find-dir
      "b" 'projectile-switch-to-buffer
      "k" 'projectile-kill-buffers
      "t" 'projectile-run-vterm
      "c" 'projectile-compile-project
      "!" 'projectile-run-shell-command-in-root
      "&" 'projectile-run-async-shell-command-in-root))
#+end_src
** Git (=magit=)
#+begin_src emacs-lisp
  (use-package magit
    :custom
    (magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
    (magit-bury-buffer-function #'magit-restore-window-configuration)
    (magit-save-repository-buffers 'dontask)
    (magit-no-confirm '(stage-all-changes unstage-all-changes))
    
    :config
    (setq magit-repository-directories
          (mapcar (lambda (dir)
                    (cons dir 1))
                  projectile-known-projects))

    (my-leader-def
      :infix "g"
      "g" 'magit-status
      "b" 'magit-blame
      "c" 'magit-commit
      "C" 'magit-clone
      "f" 'magit-file-dispatch
      "l" 'magit-log-buffer-file
      "L" 'magit-log-current
      "s" 'magit-stage-file
      "S" 'magit-stage-modified
      "u" 'magit-unstage-file
      "p" 'magit-push
      "P" 'magit-pull
      "x" 'magit-reset-quickly
      "/" 'magit-dispatch))
#+end_src
* Languages
** Common
#+begin_src emacs-lisp
  (defun my/setup-language-defaults ()
    "Set up common language support features."
    (flycheck-mode)
    (electric-pair-local-mode)
    (rainbow-delimiters-mode)
    (show-paren-mode))

  (add-hook 'prog-mode-hook #'my/setup-language-defaults)

  ;; Navigation bindings for all programming modes
  (my-local-leader-def
    :keymaps 'prog-mode-map
    :infix "g"
    "d" 'eglot-find-declaration
    "r" 'eglot-find-references
    "i" 'eglot-find-implementation
    "t" 'eglot-find-typeDefinition)
#+end_src
** Clojure (=cider=)
#+begin_src emacs-lisp
  (use-package clojure-mode
    :after (lispyville)
    :mode "\\.clj\\'"
    
    :config
    (setf (alist-get 'clojure-mode apheleia-mode-alist) 'cljstyle)
    (setf (alist-get 'cljstyle apheleia-formatters) '("cljstyle" "pipe")))

  (use-package cider
    :after clojure-mode
    :custom
    (cider-repl-display-help-banner nil)
    (cider-show-error-buffer t)
    (cider-auto-select-error-buffer t)
    (cider-repl-history-file (no-littering-expand-var-file-name "cider-history"))
    (cider-repl-wrap-history t)
    (cider-repl-history-size 1000)

    :config
    (my-local-leader-def
      :keymaps 'clojure-mode-map
      :infix "e"
      "D" 'cider-insert-defun-in-repl
      "E" 'cider-insert-last-sexp-in-repl
      "R" 'cider-insert-region-in-repl
      "b" 'cider-eval-buffer
      "d" 'cider-eval-defun-at-point
      "e" 'cider-eval-last-sexp
      "r" 'cider-eval-region
      "u" 'cider-undef
      "i" 'cider-debug-defun-at-point)

    (my-local-leader-def
      :keymaps 'clojure-mode-map
      :infix "g"
      "b" 'cider-pop-back
      "g" 'cider-find-var
      "n" 'cider-find-ns)

    (my-local-leader-def
      :keymaps 'clojure-mode-map
      :infix "h"
      "a" 'cider-apropos
      "c" 'cider-clojuredocs
      "d" 'cider-doc
      "j" 'cider-javadoc
      "n" 'cider-find-ns
      "w" 'cider-clojuredocs-web)

    (my-local-leader-def
      :keymaps 'clojure-mode-map
      :infix "i"
      "e" 'cider-enlighten-mode
      "i" 'cider-inspect
      "r" 'cider-inspect-last-result)

    (my-local-leader-def
      :keymaps 'clojure-mode-map
      :infix "n"
      "N" 'cider-browse-ns-all
      "n" 'cider-browse-ns
      "r" 'cider-ns-refresh
      "u" 'cider-undef)

    (my-local-leader-def
      :keymaps 'clojure-mode-map
      :infix "p"
      "d" 'cider-pprint-eval-defun-at-point
      "D" 'cider-pprint-eval-defun-to-comment
      "p" 'cider-pprint-eval-last-sexp
      "P" 'cider-pprint-eval-last-sexp-to-comment
      "r" 'cider-pprint-eval-last-sexp-to-repl)

    (my-local-leader-def
      :keymaps 'clojure-mode-map
      :infix "r"
      "L" 'cider-load-buffer-and-switch-to-repl-buffer
      "R" 'cider-restart
      "b" 'cider-switch-to-repl-buffer
      "c" 'cider-find-and-clear-repl-output
      "l" 'cider-load-buffer
      "n" 'cider-repl-set-ns
      "q" 'cider-quit
      "r" 'cider-ns-refresh
      "i" 'cider-interrupt)

    (my-local-leader-def
      :keymaps 'clojure-mode-map
      :infix "t"
      "a" 'cider-test-rerun-test
      "l" 'cider-test-run-loaded-tests
      "n" 'cider-test-run-ns-tests
      "p" 'cider-test-run-project-tests
      "r" 'cider-test-rerun-failed-tests
      "s" 'cider-test-run-ns-tests-with-filters
      "t" 'cider-test-run-test)

    (my-local-leader-def
      :keymaps 'clojure-mode-map
      "'" 'cider-jack-in-clj
      "\"" 'cider-jack-in-cljs
      "C" 'cider-connect-cljs
      "c" 'cider-connect-clj
      "m" 'cider-macroexpand-1
      "M" 'cider-macroexpand-all))

  (with-eval-after-load 'clojure-mode
    (setq lispy-clojure-eval-method 'cider))
#+end_src
** Nix (=nix-ts-mode=)
#+begin_src emacs-lisp
  (use-package nix-ts-mode
    :mode "\\.nix\\'"
    :custom
    (nix-nixfmt-bin "nixfmt")
    :config
    (with-eval-after-load 'apheleia
      (setf (alist-get 'nix-ts-mode apheleia-mode-alist) 'nixfmt)
      (setf (alist-get 'nixfmt apheleia-formatters)
        '("nixfmt" "-"))))
#+end_src
** Emacs Lisp
#+begin_src emacs-lisp
  (my-local-leader-def
    :infix "e"
    :keymaps 'emacs-lisp-mode-map
    "b" 'eval-buffer
    "e" 'eval-last-sexp
    "f" 'eval-defun)
#+end_src

#+begin_src emacs-lisp
  (with-eval-after-load 'emacs-lisp-mode
    (setq lispy-eval-display-style 'overlay))
#+end_src
** Rust
#+begin_src emacs-lisp
  (use-package rust-mode
    :mode "\\.rs\\'"
    :config
    (add-to-list 'eglot-server-programs
                 '(rust-mode . ("rust-analyzer")))

    (with-eval-after-load 'apheleia
      (setf (alist-get 'rust-mode apheleia-mode-alist) 'rustfmt)
      (setf (alist-get 'rustfmt apheleia-formatters)
            '("rustfmt" "--edition" "2021")))

    (my-local-leader-def
      :keymaps 'rust-mode-map
      "b" 'rust-compile
      "r" 'rust-run
      "tb" (cons my/rust-build-map)))
#+end_src
** Typescript (=typescript-ts-mode=)
#+begin_src emacs-lisp
  (use-package typescript-ts-mode
    :mode (("\\.ts\\'" . typescript-ts-mode)
           ("\\.tsx\\'" . tsx-ts-mode))
    :config
    (add-to-list 'eglot-server-programs
                 '((typescript-ts-mode . ("typescript-language-server" "--stdio"))
                   (tsx-ts-mode . ("typescript-language-server" "--stdio")))))
#+end_src
** Shell
#+begin_src emacs-lisp
  (use-package sh-script
    :ensure nil  ; built-in
    :custom
    (sh-basic-offset 2)
    (sh-indentation 2))
#+end_src
** Lua (=lua-mode=)
#+begin_src emacs-lisp
  (use-package lua-mode
    :mode "\\.lua\\'"
    :interpreter "lua"
    :custom
    (lua-indent-level 2)
    (lua-indent-string-contents t)
    (lua-prefix-key nil)  ; Don't override any prefix keys
    :config
    ;; Configure LSP (using lua-language-server)
    (add-to-list 'eglot-server-programs
                 '(lua-mode . ("lua-language-server")))

    ;; Better syntax highlighting
    (setq lua-font-lock-keywords
          (append lua-font-lock-keywords
                  '(("\\<\\(self\\)\\>" . font-lock-keyword-face))))

    (with-eval-after-load 'apheleia
        (setf (alist-get 'lua-mode apheleia-mode-alist) 'stylua)
        (setf (alist-get 'stylua apheleia-formatters)
              '("stylua" "-"))))


  ;; Lua-specific keybindings
  (my-local-leader-def
    :keymaps 'lua-mode-map

    ;; Evaluation
    "e" '(:ignore t :which-key "eval")
    "eb" '(lua-send-buffer :which-key "eval buffer")
    "ef" '(lua-send-defun :which-key "eval function")
    "el" '(lua-send-current-line :which-key "eval line")
    "er" '(lua-send-region :which-key "eval region")

    ;; Documentation
    "h" '(:ignore t :which-key "help")
    "hh" '(eldoc :which-key "documentation at point")
    "hr" '(xref-find-references :which-key "find references")

    ;; Format
    "=" '(apheleia-format-buffer :which-key "format buffer")

    ;; Testing (if using busted or luaunit)
    "t" '(:ignore t :which-key "test")
    "tb" '(lua-send-buffer-and-test :which-key "test buffer")
    "tf" '(lua-send-defun-and-test :which-key "test function")
    "tt" '(lua-run-tests :which-key "run all tests")

    ;; Navigation
    "g" '(:ignore t :which-key "goto")
    "gg" '(xref-find-definitions :which-key "goto definition")
    "gr" '(xref-find-references :which-key "find references")
    "gi" '(eglot-find-implementation :which-key "goto implementation")

    ;; Code actions
    "c" '(:ignore t :which-key "code")
    "cr" '(eglot-rename :which-key "rename")
    "ca" '(eglot-code-actions :which-key "code actions")
    "cf" '(apheleia-format-buffer :which-key "format buffer"))

  ;; Optional: Add support for Neovim configuration if needed
  (add-to-list 'auto-mode-alist '("init\\.lua\\'" . lua-mode))
  (add-to-list 'auto-mode-alist '("\\.nvim/lua/.*\\.lua\\'" . lua-mode))

  ;; Helper functions for Lua development
  (defun lua-send-buffer-and-test ()
    "Send buffer to Lua REPL and run tests."
    (interactive)
    (lua-send-buffer)
    (lua-run-tests))

  (defun lua-send-defun-and-test ()
    "Send current function to Lua REPL and run its tests."
    (interactive)
    (lua-send-defun)
    (lua-run-tests))

  (defun lua-run-tests ()
    "Run Lua tests using the configured test runner."
    (interactive)
    (let ((test-command
           (cond
            ((file-exists-p "busted") "busted")
            ((file-exists-p "luaunit") "lua -lluaunit")
            (t "lua test.lua"))))
      (compile test-command)))
#+end_src
* Applications
** Terminal (=vterm=)
#+begin_src emacs-lisp
  (use-package vterm
    :commands vterm
    :custom
    (vterm-max-scrollback 10000)
    (vterm-buffer-name-string "vterm: %s")
    :config
    (evil-set-initial-state 'vterm-mode 'insert))
#+end_src
*** Bindings
#+begin_src emacs-lisp
  (my-leader-def
    "ot" '(:ignore t :which-key "terminal")
    "ott" '(vterm :which-key "new terminal")
    "otv" '(vterm-other-window :which-key "terminal in split"))
#+end_src
** IRC (=erc=)
;; IRC (ERC) configuration for Soju and Libera
#+begin_src emacs-lisp
  (defun my/read-token (fp)
      (when (file-exists-p fp)
        (string-trim (with-temp-buffer
                       (insert-file-contents "~/.irc-soju.token")
                       (buffer-string))))
    )

  (use-package erc
    :ensure nil 
    :commands (erc erc-tls)
    :init

    (setq erc-nick "psyclyx"
          erc-nick-uniquifier "2"
          erc-user-full-name "psyclyx pseudoangel")

    (defun my/erc-connect-soju ()
      (interactive)
      (let ((soju-pass (my/read-token "~/.irc-soju.token")))
        (erc-tls :server "ix"
                 :port 6697
                 :nick erc-nick
                 :full-name erc-user-full-name
                 :password soju-pass)))


    :config
    (add-hook 'erc-mode-hook 'evil-insert-state)

    ;; Commented-out: NickServ auto-auth for Libera (uncomment and edit if needed)
    ;; (add-to-list 'erc-modules 'services)        ;; enable the "services" (NickServ) module
    ;; (setq erc-prompt-for-nickserv-password nil  ;; don't prompt, use saved password
    ;;       erc-nickserv-passwords
    ;;       '((Libera.Chat (("psyclyx" . "YOUR_LIBERA_NICKSERV_PASSWORD")))))
    )


  (my-leader-def
    "oi" '(my/erc-connect-soju :which-key "Connect to IRC (ix soju)"))
#+end_src

** =gptel=
*** Packages
#+begin_src emacs-lisp
  (use-package gptel
    :custom
    (gptel-default-mode 'org-mode)
    (gptel-org-branching-context t)

    :config
    (setf (alist-get 'org-mode gptel-prompt-prefix-alist) "@user\n")
    (setf (alist-get 'org-mode gptel-response-prefix-alist) "@assistant\n"))
#+end_src

*** Model definitions
#+begin_src emacs-lisp
  (when (file-exists-p "~/.openai-token")
    (defun read-openai-token ()
      "Read OpenAI API token from ~/.openrouter-token file."
      (with-temp-buffer
        (insert-file-contents (expand-file-name "~/.openrouter-token"))
        (string-trim (buffer-string))))
    (setq gptel-api-key 'read-openai-token))

  (defun fetch-openrouter-models ()
    (with-current-buffer
        (url-retrieve-synchronously "https://openrouter.ai/api/v1/models")
      (goto-char url-http-end-of-headers)
      (let* ((json-object-type 'alist)
             (json-data (json-read))
             (models (alist-get 'data json-data)))
        (mapcar (lambda (model)
                  (cons (alist-get 'name model)
                        (alist-get 'id model)))
                models))))

  (when (file-exists-p "~/.openrouter-token")
    (defun read-openrouter-token ()
      "Read OpenRouter API token from ~/.openrouter-token file."
      (with-temp-buffer
        (insert-file-contents (expand-file-name "~/.openrouter-token"))
        (string-trim (buffer-string))))
    (gptel-make-openai "OpenRouter"
      :host "openrouter.ai"
      :endpoint "/api/v1/chat/completions"
      :stream t
      :key (read-openrouter-token)
      :models (mapcar (lambda (model)
                        (cdr model))
                      (fetch-openrouter-models))))

  (when (file-exists-p "~/.gptel.el")
    (load-file "~/.gptel.el")
    (when (fboundp 'config:gptel)
      (config:gptel)))

#+end_src
*** Bindings
#+begin_src emacs-lisp
  (my-leader-def
    "SPC" '(:ignore t :which-key "ai")
    "SPC SPC" '(:ignore t :which-key "gptel")
    "SPC SPC RET" '(gptel-send :which-key "send")
    "SPC SPC n" '(gptel :which-key "new chat")
    "SPC SPC m" '(gptel-menu :which-key "model menu")
    "SPC SPC r" '(gptel-rewrite :which-key "rewrite"))
#+end_src

** Evedel
#+begin_src emacs-lisp
  (use-package evedel
    :config
    (customize-set-variable 'evedel-empty-tag-query-matches-all nil)

    (my-leader-def
      "SPC h" 'evedel-next-instruction
      "SPC l" 'evedel-previous-instruction

      "SPC j" 'evedel-next-directive
      "SPC k" 'evedel-previous-directive

      "SPC J" 'evedel-next-reference
      "SPC K" 'evedel-previous-reference

      "SPC ," 'evedel-cycle-instructions-at-point


      "SPC d" '(:ignore t :which-key "directive")
      "SPC d n" 'evedel-create-directive
      "SPC d r" 'evedel-modify-directive

      "SPC r" '(:ignore t :which-key "reference")
      "SPC r n" 'evedel-create-reference
      "SPC r r" 'evedel-modify-reference-commentary


      "SPC i" '(:ignore t :which-key "instructions")
      "SPC i e" 'evedel-load-instructions
      "SPC i w" 'evedel-save-instructions
      "SPC i x" 'evedel-delete-instructions
      "SPC i c" 'evedel-convert-instructions
      "SPC i X" 'evedel-delete-all-instructions
      "SPC i l" 'evedel-link-instructions
      "SPC i L" 'evedel-unlink-instructions


      "SPC t" '(:ignore t "tags")
      "SPC t t" 'evedel-add-tags
      "SPC t T" 'evedel-remove-tags
      "SPC t r" 'evedel-modify-directive-tag-query

      "SPC v" 'evedel-preview-directive-prompt
      "SPC u" 'evedel-directive-undo

      "SPC RET" 'evedel-process-directives))
#+end_src
** =direnv= & =envrc=
#+begin_src emacs-lisp
  (use-package direnv
    :config
    (direnv-mode))

  (use-package envrc
    :config
    (envrc-global-mode))
#+end_src
** =org-mode=
#+begin_src emacs-lisp
  (use-package org
    :config
    (unless (file-exists-p "~/Sync/org")
      (make-directory "~/Sync/org" t))

    (setq org-directory "~/Sync/org"
          org-agenda-files '("~/Sync/org/agenda.org")
          org-log-done 'time

          org-todo-keywords '((sequence
                               "TODO(t)" "NEXT(n)" "PROGRESS(p)" "WAITING(w@/!)"
                               "QUESTION(q)" "|" "DONE(d)" "ANSWERED(a)" "CANCELLED(c@)"))

          org-todo-keyword-faces '(("NEXT" . (:foreground "orange" :weight bold))
                                   ("WAITING" . (:foreground "yellow" :weight bold))
                                   ("PROGRESS" . (:foreground "blue" :weight bold)))

          org-refile-targets '((nil :maxlevel . 9)
                               (org-agenda-files :maxlevel . 9))
          org-refile-use-outline-path 'file
          org-outline-path-complete-in-steps nil
          org-capture-templates
          '(("t" "Todo" entry (file+headline "~/Sync/org/agenda.org" "Inbox")
             "* TODO %?
  :PROPERTIES:
  :CREATED: %U
  :END:
  %i"
             :prepend t)
            ("n" "note" entry (file+headline "~/Sync/org/agenda.org" "Inbox")
             "* %?
  :PROPERTIES:
  :CREATED: %U
  :END:
  %i"
             :prepend t)
            ("c" "Current Clock Note" entry (clock)
             "* %<%H:%M> %^{Title|Note|Quick thought|Update|Status}
  %?"
  	       :prepend t
             :clock-keep t)
            ("j" "Journal" entry (file+datetree "~/Sync/org/journal.org")
             "* %?
  :PROPERTIES:
  :CREATED: %U
  :END:
  %i
  ")))

    (setq org-agenda-custom-commands
          '(("n" "Next Tasks"
             ((todo "NEXT"
                    ((org-agenda-overriding-header "Next Tasks")))))
            ("w" "Waiting Tasks"
             ((todo "WAITING"
                    ((org-agenda-overriding-header "Waiting For")))))))

    (setq org-display-custom-times t
          org-time-stamp-custom-formats '("<%Y-%m-%d %a>" . "<%Y-%m-%d %a %H:%M>"))


    ;; Clock settings
    (setq org-clock-persist 'history
          org-clock-persist-query-resume nil
          org-clock-in-resume t
          org-clock-out-remove-zero-time-clocks t
          org-clock-clocked-in-display 'mode-line
          org-clock-into-drawer t)

    ;; Save clock history when emacs is closed
    (org-clock-persistence-insinuate))

  (use-package org-indent
    :after org
    :config
    (setq org-startup-indented 1))
#+end_src

#+begin_src emacs-lisp
  (use-package org-superstar
    :hook (org-mode-hook . org-superstar-mode)
    :custom
    (org-superstar-headline-bullets-list '("🜂" "🜃" "🜄" "🜁" "🜔" "🜖")))
#+end_src

#+begin_src emacs-lisp
  (set-face-attribute 'org-document-title nil :height 1.75)
  (set-face-attribute 'org-document-info nil :height 1.3)
  (set-face-attribute 'org-level-1 nil :height 1.6)
  (set-face-attribute 'org-level-2 nil :height 1.45)
  (set-face-attribute 'org-level-3 nil :height 1.3)
  (set-face-attribute 'org-level-4 nil :height 1.15)
#+end_src
*** org-roam
**** Enable
#+begin_src emacs-lisp
  (use-package org-roam
    :after org)

#+end_src
**** Database location
#+begin_src emacs-lisp
    (unless (file-exists-p "~/Sync/org/roam")
          (make-directory "~/Sync/org/roam" t))

  (setq org-roam-directory "~/Sync/org/roam")
#+end_src
**** Autosync database
#+begin_src emacs-lisp
  (org-roam-db-autosync-mode)
#+end_src
*** Utilities
#+begin_src emacs-lisp
  (defun my/org-insert-directory-structure (dir level)
    "Insert directory structure as org-mode links starting at DIR with heading LEVEL."
    (interactive "DDirectory: \nnStarting level (e.g., 2 for **): ")
    (dolist (file (directory-files dir))
      (unless (member file '("." ".."))
        (let ((path (concat dir "/" file)))
          (insert (make-string level ?*) " "
                  "[[file:" path "][" file "/]]\n")
          (when (file-directory-p path)
            (my/org-insert-directory-structure path (1+ level)))))))
#+end_src
Screenshot 2025-04-19 at 10.56.18 PM.png*** Bindings
#+begin_src emacs-lisp
  (my-leader-def
    "n" '(:ignore t :which-key "notes")
    "na" '(org-agenda :which-key "agenda")
    "nc" '(org-capture :which-key "capture")
    "nl" '(org-store-link :which-key "store link")
    "ni" '(org-insert-link :which-key "insert link")
    "ns" '(org-search-view :which-key "search")
    "nt" '(org-todo-list :which-key "todo list")
    "nj" '(org-journal-new-entry :which-key "journal entry")
    "nb" '(org-switchb :which-key "switch org buffer")

    "nC" '(:ignore t :which-key "clock")
    "nCg" '(org-clock-goto :which-key "goto clock")
    "nCo" '(org-clock-out :which-key "clock out")
    "nCm" '(org-clock-menu :which-key "clock menu")

    "nr" '(:ignore t :which-key "roam")
    "nri" '(org-roam-node-insert :which-key "insert node")
    "nrf" '(org-roam-node-find :which-key "find node")
    "nrc" '(org-roam-capture :which-key "capture"))
#+end_src

#+begin_src emacs-lisp
  (my-local-leader-def
    :keymaps 'org-mode-map
    "r" '(org-refile :which-key "refile subtree")
    "t" '(org-todo :which-key "cycle todo state")
    "." '(org-time-stamp :which-key "insert timestamp")
    "d" '(org-deadline :which-key "set deadline")
    "s" '(org-schedule :which-key "schedule todo"))
#+end_src

